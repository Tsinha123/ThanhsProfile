<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Thanh's Profile</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto 1fr;
      height: 100vh;
      overflow: hidden;
    }
    header {
      grid-column: 1 / 4;
      display: flex;
      align-items: center;
      padding: 10px 20px;
      font-size: 24px;
      font-weight: bold;
      background: #222;
      color: white;
    }
    .ribbon {
      grid-column: 1 / 4;
      height: 8px;
      background: linear-gradient(to right, #f06, #f79);
    }
    main {
      grid-column: 1 / 4;
      overflow-y: auto;
      padding: 20px;
      background: #f5f5dc; /* Tanish background */
      display: flex;
      flex-direction: column;
      gap: 30px;
      align-items: center;
    }
    section {
      background: #fafafa;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      width: 640px;
    }
    .game-title {
      color: #333;
      margin-bottom: 10px;
      font-weight: 600;
      text-align: center;
      font-size: 22px;
    }
    canvas {
      background: #222;
      display: block;
      margin: 0 auto;
      border-radius: 8px;
      box-shadow: 0 0 10px #f06;
      cursor: default;
    }
  </style>
</head>
<body>
  <header>Thanh's Profile</header>
  <div class="ribbon"></div>

  <main>
    <section id="crossy-road-section">
      <h3 class="game-title">Crossy Road Clone</h3>
      <canvas id="crossyRoad" width="600" height="450"></canvas>
    </section>

    <section id="flappy-bird-section">
      <h3 class="game-title">Flappy Bird Clone</h3>
      <canvas id="flappyBird" width="600" height="450"></canvas>
    </section>

    <section id="ping-pong-section">
      <h3 class="game-title">Ping Pong</h3>
      <canvas id="pingPong" width="600" height="450"></canvas>
    </section>
  </main>

<script>
  /* ===== Crossy Road Clone ===== */
  const crossyCanvas = document.getElementById('crossyRoad');
  const crossyCtx = crossyCanvas.getContext('2d');

  const crossy = {
    width: crossyCanvas.width,
    height: crossyCanvas.height,
    player: { x: 280, y: 410, size: 30 },
    lanes: [
      { y: 360, speed: 2, cars: [] },
      { y: 290, speed: -3, cars: [] },
      { y: 230, speed: 1.5, cars: [] },
      { y: 170, speed: -2.5, cars: [] },
    ],
    keys: {}
  };

  crossy.lanes.forEach(lane => {
    for (let i = 0; i < 4; i++) {
      lane.cars.push({
        x: Math.random() * crossy.width,
        width: 80,
        height: 30,
      });
    }
  });

  function drawCrossy() {
    crossyCtx.clearRect(0, 0, crossy.width, crossy.height);
    crossyCtx.fillStyle = '#555';
    crossy.lanes.forEach(lane => {
      crossyCtx.fillRect(0, lane.y, crossy.width, 40);
    });
    crossyCtx.fillStyle = 'red';
    crossy.lanes.forEach(lane => {
      lane.cars.forEach(car => {
        crossyCtx.fillRect(car.x, lane.y + 5, car.width, 30);
      });
    });
    crossyCtx.fillStyle = 'lime';
    crossyCtx.fillRect(crossy.player.x, crossy.player.y, crossy.player.size, crossy.player.size);
  }

  function updateCrossy() {
    crossy.lanes.forEach(lane => {
      lane.cars.forEach(car => {
        car.x += lane.speed;
        if (lane.speed > 0 && car.x > crossy.width) car.x = -car.width;
        else if (lane.speed < 0 && car.x + car.width < 0) car.x = crossy.width;
      });
    });

    if (crossy.keys['ArrowUp']) crossy.player.y -= 5;
    if (crossy.keys['ArrowDown']) crossy.player.y += 5;
    if (crossy.keys['ArrowLeft']) crossy.player.x -= 5;
    if (crossy.keys['ArrowRight']) crossy.player.x += 5;

    crossy.player.x = Math.max(0, Math.min(crossy.width - crossy.player.size, crossy.player.x));
    crossy.player.y = Math.max(0, Math.min(crossy.height - crossy.player.size, crossy.player.y));

    for (let lane of crossy.lanes) {
      for (let car of lane.cars) {
        if (
          crossy.player.x < car.x + car.width &&
          crossy.player.x + crossy.player.size > car.x &&
          crossy.player.y < lane.y + 40 &&
          crossy.player.y + crossy.player.size > lane.y
        ) {
          crossy.player.x = 280;
          crossy.player.y = 410;
        }
      }
    }
  }

  function crossyLoop() {
    updateCrossy();
    drawCrossy();
    requestAnimationFrame(crossyLoop);
  }

  window.addEventListener('keydown', e => crossy.keys[e.key] = true);
  window.addEventListener('keyup', e => crossy.keys[e.key] = false);
  crossyLoop();

  /* ===== Flappy Bird Clone ===== */
  const flappyCanvas = document.getElementById('flappyBird');
  const flappyCtx = flappyCanvas.getContext('2d');

  const flappy = {
    width: flappyCanvas.width,
    height: flappyCanvas.height,
    bird: { x: 75, y: 225, radius: 18, velocity: 0 },
    gravity: 0.6,
    lift: -10,
    pipes: [],
    frameCount: 0,
    pipeWidth: 80,
    pipeGap: 160,
    gameOver: false,
    score: 0
  };

  function createPipe() {
    const topHeight = Math.random() * (flappy.height / 2);
    flappy.pipes.push({
      x: flappy.width,
      topHeight,
      bottomY: topHeight + flappy.pipeGap,
      bottomHeight: flappy.height - (topHeight + flappy.pipeGap)
    });
  }

  function drawFlappy() {
    flappyCtx.clearRect(0, 0, flappy.width, flappy.height);

    flappyCtx.fillStyle = 'yellow';
    flappyCtx.beginPath();
    flappyCtx.arc(flappy.bird.x, flappy.bird.y, flappy.bird.radius, 0, Math.PI * 2);
    flappyCtx.fill();

    flappyCtx.fillStyle = 'green';
    flappy.pipes.forEach(pipe => {
      flappyCtx.fillRect(pipe.x, 0, flappy.pipeWidth, pipe.topHeight);
      flappyCtx.fillRect(pipe.x, pipe.bottomY, flappy.pipeWidth, pipe.bottomHeight);
    });

    flappyCtx.fillStyle = '#222';
    flappyCtx.font = '24px Arial';
    flappyCtx.fillText(`Score: ${flappy.score}`, 15, 35);

    if (flappy.gameOver) {
      flappyCtx.fillStyle = 'red';
      flappyCtx.font = '48px Arial';
      flappyCtx.fillText('Game Over', flappy.width / 2 - 130, flappy.height / 2);
      flappyCtx.font = '24px Arial';
      flappyCtx.fillText('Click to restart', flappy.width / 2 - 90, flappy.height / 2 + 40);
    }
  }

  function updateFlappy() {
    if (flappy.gameOver) return;

    flappy.bird.velocity += flappy.gravity;
    flappy.bird.y += flappy.bird.velocity;

    if (flappy.frameCount % 90 === 0) createPipe();

    flappy.pipes.forEach(pipe => {
      pipe.x -= 3;

      if (pipe.x + flappy.pipeWidth === flappy.bird.x) {
        flappy.score++;
      }

      if (
        flappy.bird.x + flappy.bird.radius > pipe.x &&
        flappy.bird.x - flappy.bird.radius < pipe.x + flappy.pipeWidth &&
        (
          flappy.bird.y - flappy.bird.radius < pipe.topHeight ||
          flappy.bird.y + flappy.bird.radius > pipe.bottomY
        )
      ) {
        flappy.gameOver = true;
      }
    });

    flappy.pipes = flappy.pipes.filter(pipe => pipe.x + flappy.pipeWidth > 0);

    if (flappy.bird.y + flappy.bird.radius > flappy.height || flappy.bird.y < 0) {
      flappy.gameOver = true;
    }

    flappy.frameCount++;
  }

  flappyCanvas.addEventListener('click', () => {
    if (flappy.gameOver) {
      flappy.bird.y = 225;
      flappy.bird.velocity = 0;
      flappy.pipes = [];
      flappy.frameCount = 0;
      flappy.score = 0;
      flappy.gameOver = false;
    } else {
      flappy.bird.velocity = flappy.lift;
    }
  });

  function flappyLoop() {
    updateFlappy();
    drawFlappy();
    requestAnimationFrame(flappyLoop);
  }
  flappyLoop();

  /* ===== Ping Pong with Arrow Keys ===== */
  const pingPongCanvas = document.getElementById('pingPong');
  const ppCtx = pingPongCanvas.getContext('2d');

  const pingPong = {
    width: pingPongCanvas.width,
    height: pingPongCanvas.height,
    paddleWidth: 15,
    paddleHeight: 100,
    ballRadius: 12,
    leftPaddle: { x: 10, y: 175, speed: 8 },
    rightPaddle: { x: 575, y: 175, speed: 6 },
    ball: { x: 300, y: 225, velocityX: 6, velocityY: 4 },
    keys: {},
    playerScore: 0,
    aiScore: 0,
  };

  function drawPingPong() {
    ppCtx.clearRect(0, 0, pingPong.width, pingPong.height);

    ppCtx.strokeStyle = '#f06';
    ppCtx.lineWidth = 3;
    ppCtx.setLineDash([15, 10]);
    ppCtx.beginPath();
    ppCtx.moveTo(pingPong.width/2, 0);
    ppCtx.lineTo(pingPong.width/2, pingPong.height);
    ppCtx.stroke();
    ppCtx.setLineDash([]);

    ppCtx.fillStyle = 'lime';
    ppCtx.fillRect(pingPong.leftPaddle.x, pingPong.leftPaddle.y, pingPong.paddleWidth, pingPong.paddleHeight);
    ppCtx.fillRect(pingPong.rightPaddle.x, pingPong.rightPaddle.y, pingPong.paddleWidth, pingPong.paddleHeight);

    ppCtx.fillStyle = 'white';
    ppCtx.beginPath();
    ppCtx.arc(pingPong.ball.x, pingPong.ball.y, pingPong.ballRadius, 0, Math.PI * 2);
    ppCtx.fill();

    ppCtx.fillStyle = '#222';
    ppCtx.font = '24px Arial';
    ppCtx.fillText(pingPong.playerScore, pingPong.width / 4, 40);
    ppCtx.fillText(pingPong.aiScore, pingPong.width * 3 / 4, 40);
  }

  function updatePingPong() {
    // Use Arrow Keys instead of W/S
    if (pingPong.keys['ArrowUp']) pingPong.leftPaddle.y -= pingPong.leftPaddle.speed;
    if (pingPong.keys['ArrowDown']) pingPong.leftPaddle.y += pingPong.leftPaddle.speed;
    pingPong.leftPaddle.y = Math.max(0, Math.min(pingPong.height - pingPong.paddleHeight, pingPong.leftPaddle.y));

    const aiCenter = pingPong.rightPaddle.y + pingPong.paddleHeight / 2;
    const deltaY = pingPong.ball.y - aiCenter;
    if (pingPong.ball.velocityX > 0) {
      pingPong.rightPaddle.y += deltaY * 0.15;
    }
    pingPong.rightPaddle.y = Math.max(0, Math.min(pingPong.height - pingPong.paddleHeight, pingPong.rightPaddle.y));

    pingPong.ball.x += pingPong.ball.velocityX;
    pingPong.ball.y += pingPong.ball.velocityY;

    if (pingPong.ball.y + pingPong.ballRadius > pingPong.height || pingPong.ball.y - pingPong.ballRadius < 0) {
      pingPong.ball.velocityY *= -1;
    }

    // Collision with player
    if (
      pingPong.ball.x - pingPong.ballRadius < pingPong.leftPaddle.x + pingPong.paddleWidth &&
      pingPong.ball.y > pingPong.leftPaddle.y &&
      pingPong.ball.y < pingPong.leftPaddle.y + pingPong.paddleHeight
    ) {
      pingPong.ball.velocityX *= -1;
      pingPong.ball.x = pingPong.leftPaddle.x + pingPong.paddleWidth + pingPong.ballRadius;
    }

    // Collision with AI
    if (
      pingPong.ball.x + pingPong.ballRadius > pingPong.rightPaddle.x &&
      pingPong.ball.y > pingPong.rightPaddle.y &&
      pingPong.ball.y < pingPong.rightPaddle.y + pingPong.paddleHeight
    ) {
      pingPong.ball.velocityX *= -1;
      pingPong.ball.x = pingPong.rightPaddle.x - pingPong.ballRadius;
    }

    // Score
    if (pingPong.ball.x < 0) {
      pingPong.aiScore++;
      resetPingPong();
    } else if (pingPong.ball.x > pingPong.width) {
      pingPong.playerScore++;
      resetPingPong();
    }
  }

  function resetPingPong() {
    pingPong.ball.x = pingPong.width / 2;
    pingPong.ball.y = pingPong.height / 2;
    pingPong.ball.velocityX *= -1;
    pingPong.ball.velocityY = 4 * (Math.random() > 0.5 ? 1 : -1);
    pingPong.leftPaddle.y = pingPong.height / 2 - pingPong.paddleHeight / 2;
    pingPong.rightPaddle.y = pingPong.height / 2 - pingPong.paddleHeight / 2;
  }

  function pingPongLoop() {
    updatePingPong();
    drawPingPong();
    requestAnimationFrame(pingPongLoop);
  }

  window.addEventListener('keydown', e => pingPong.keys[e.key] = true);
  window.addEventListener('keyup', e => pingPong.keys[e.key] = false);
  pingPongLoop();
</script>
</body>
</html>
